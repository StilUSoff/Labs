








Лабораторная работа №0
а) Случайно сгенерировать файл в 10 тысяч символов, используя указанный алфавит
(заглавные и строчные буквы). Закодировать текстовую информацию, используя указанный в
задании алгоритм. Определить цену кодирования. Декодировать информацию, определить
коэффициент сжатия. Программно проверить, что декодирование произошло верно.
б) Закодировать информацию алгоритмом RLE. Декодировать информацию, определить
коэффициент сжатия. Программно проверить, что декодирование произошло верно.
в) Аналогично пункту а) закодировать информацию, применив двухступенчатое кодирование
(RLE + алгоритм варианта и алгоритм варианта + RLE). Показать, какой из способов более
эффективный.
A - Алгоритм Фано
B - Алгоритм Хаффмена
C - Алгоритм LZW

3- {н, о, п, р, с, т, пробел, 0-9, $, .} Алгоритм C










// #include <iostream>
// #include <fstream>
// #include <vector>
// #include <string>
// #include <algorithm>

// using namespace std;

// // Функция для генерации случайного символа из алфавита
// char getRandomChar() {
//     string alphabet = "нопрст 0123456789$.";
//     return alphabet[rand() % alphabet.size()];
// }

// // Функция для генерации случайного текста
// string generateRandomText(int length) {
//     string text;
//     text.reserve(length);
//     for (int i = 0; i < length; ++i) {
//         text += getRandomChar();
//     }
//     return text;
// }

// // Функция для кодирования текста алгоритмом LZW
// vector<int> encodeLZW(const string& text) {
//     vector<int> encoded;
//     vector<string> dictionary;
//     string current;
//     for (char c : text) {
//         string temp = current + c;
//         if (find(dictionary.begin(), dictionary.end(), temp) != dictionary.end()) {
//             current = temp;
//         } else {
//             encoded.push_back(find(dictionary.begin(), dictionary.end(), current) - dictionary.begin());
//             dictionary.push_back(temp);
//             current = string(1, c);
//         }
//     }
//     if (!current.empty()) {
//         encoded.push_back(find(dictionary.begin(), dictionary.end(), current) - dictionary.begin());
//     }
//     return encoded;
// }

// // Функция для декодирования текста алгоритмом LZW
// string decodeLZW(const vector<int>& encoded) {
//     string decoded;
//     vector<string> dictionary;
//     string lastEntry;
//     for (int index : encoded) {
//         string entry = dictionary[index];
//         decoded += entry;
//         if (!lastEntry.empty()) {
//             dictionary.push_back(lastEntry + entry[0]);
//         }
//         lastEntry = entry;
//     }
//     return decoded;
// }

// // Функция для кодирования текста алгоритмом RLE
// string encodeRLE(const string& text) {
//     string encoded;
//     int count = 1;
//     for (size_t i = 1; i <= text.size(); ++i) {
//         if (i == text.size() || text[i] != text[i - 1]) {
//             encoded += to_string(count) + text[i - 1];
//             count = 1;
//         } else {
//             ++count;
//         }
//     }
//     return encoded;
// }

// // Функция для декодирования текста алгоритмом RLE
// string decodeRLE(const string& encoded) {
//     string decoded;
//     for (size_t i = 0; i < encoded.size(); i += 2) {
//         int count = encoded[i] - '0';
//         char c = encoded[i + 1];
//         decoded.append(count, c);
//     }
//     return decoded;
// }

// int main() {
//     // Генерация случайного текста
//     int textLength = 10000;
//     string originalText = generateRandomText(textLength);

//     // (а) Кодирование текста алгоритмом LZW
//     vector<int> encodedText = encodeLZW(originalText);

//     // Подсчет цены кодирования
//     int originalSize = originalText.size() * 8; // Количество битов в исходном тексте
//     int encodedSize = encodedText.size() * 12; // Предполагаем, что каждый код LZW занимает 12 бит
//     double compressionRateLZW = (double)encodedSize / originalSize;
//     cout << "(а) Цена кодирования алгоритмом LZW: " << compressionRateLZW << endl;

//     // Декодирование текста алгоритмом LZW
//     string decodedTextLZW = decodeLZW(encodedText);

//     // Проверка, что декодирование произошло верно
//     if (originalText == decodedTextLZW) {
//         cout << "Декодирование алгоритмом LZW прошло успешно." << endl;
//     } else {
//         cout << "Ошибка в декодировании алгоритмом LZW." << endl;
//     }

//     // (б) Кодирование текста алгоритмом RLE
//     string encodedTextRLE = encodeRLE(originalText);

//     // Подсчет коэффициента сжатия RLE
//     double compressionRateRLE = (double)encodedTextRLE.size() * 8 / originalSize;
//     cout << "(б) Коэффициент сжатия алгоритмом RLE: " << compressionRateRLE << endl;

//     // Декодирование текста алгоритмом RLE
//     string decodedTextRLE = decodeRLE(encodedTextRLE);

//     // Проверка, что декодирование произошло верно
//     if (originalText == decodedTextRLE) {
//         cout << "Декодирование алгоритмом RLE прошло успешно." << endl;
//     } else {
//         cout << "Ошибка в декодировании алгоритмом RLE." << endl;
//     }

//     // (в) Сравнение эффективности кодирования LZW + RLE и RLE + LZW
//     // Кодирование текста алгоритмом LZW, а затем RLE
//     vector<int> encodedTextLZW = encodeLZW(originalText);
//     string encodedTextLZW_RLE = encodeRLE(decodeLZW(encodedTextLZW));

//     // Проверка, что декодирование прошло успешно
//     string decodedTextLZW_RLE = decodeRLE(encodedTextLZW_RLE);
//     if (originalText == decodedTextLZW_RLE) {
//         cout << "Декодирование алгоритмом LZW + RLE прошло успешно." << endl;
//     } else {
//         cout << "Ошибка в декодировании алгоритмом LZW + RLE." << endl;
//     }

//     // Коэффициент сжатия LZW + RLE
//     int encodedSizeLZW_RLE = encodedTextLZW_RLE.size() * 8; // Предполагаем, что каждая пара символ-количество повторений в RLE кодируется на 8 бит
//     double compressionRateLZW_RLE = (double)encodedSizeLZW_RLE / originalSize;

//     // Кодирование текста алгоритмом RLE, а затем LZW
//     string encodedTextRLE_LZW = encodeRLE(originalText);
//     vector<int> encodedTextRLE_LZW_LZW = encodeLZW(encodedTextRLE_LZW);

//     // Проверка, что декодирование прошло успешно
//     string decodedTextRLE_LZW = decodeLZW(encodedTextRLE_LZW_LZW);
//     string decodedTextRLE_LZW_RLE = decodeRLE(decodedTextRLE_LZW);
//     if (originalText == decodedTextRLE_LZW_RLE) {
//         cout << "Декодирование алгоритмом RLE + LZW прошло успешно." << endl;
//     } else {
//         cout << "Ошибка в декодировании алгоритмом RLE + LZW." << endl;
//     }

//     // Коэффициент сжатия RLE + LZW
//     int encodedSizeRLE_LZW = encodedTextRLE_LZW_LZW.size() * 12; // Предполагаем, что каждый код LZW занимает 12 бит
//     double compressionRateRLE_LZW = (double)encodedSizeRLE_LZW / originalSize;

//     cout << "(в) Сравнение эффективности кодирования:" << endl;
//     cout << "Коэффициент сжатия LZW + RLE: " << compressionRateLZW_RLE << endl;
//     cout << "Коэффициент сжатия RLE + LZW: " << compressionRateRLE_LZW << endl;

//     if (compressionRateLZW_RLE < compressionRateRLE_LZW) {
//         cout << "LZW + RLE более эффективен." << endl;
//     } else if (compressionRateLZW_RLE > compressionRateRLE_LZW) {
//         cout << "RLE + LZW более эффективен." << endl;
//     } else {
//         cout << "Оба метода имеют одинаковую эффективность." << endl;
//     }

//     return 0;
// }
